* java.util.HashMap#tableSizeFor 计算table大小
```
Node table的大小必须是2的N次幂
Returns a power of two size for the given target capacity.
```

* 初始table大小为16
```
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 1
```


* java.util.HashMap#hash 为了减小hash碰撞
```
^ 异或
>>> 无符号右移
0异或A结果为A

int h; // java中整形的长度为32位
(h = key.hashcod()) ^ (h >>> 16)  // 高16位不变，让key的hashcode的高16位与低16位作异或运算，得到一个比较分散的值，目的是为了减小hash碰撞

```

* java.util.HashMap#putVal中tab[i = (n - 1) & hash]
```
n为2的整数次幂(这个前提很重要)，假设为初始值：DEFAULT_INITIAL_CAPACITY（这里取n=16）
(n - 1) & hash 相当于取模运算，决定node放在table的哪个位置，即index
------------------------------------------------------------------------
(16)2   = 0000 0000 0001 0000
(16-1)2 = 0000 0000 0000 1111  &上任意数，即只用低4位参与运算，值永远小于16
------------------------------------------------------------------------
若hash=20  
(20)2   = 0000 0000 0001 0100
若hash=200
(200)2  = 0000 0000 1100 1000
------------------------------------------------------------------------
无论hash多大，只用低(这里是4)位参与运算，值永远小于n
不是所有的取模运算都能这样写，n必须是2的整数次幂
只有当n为2的整数次幂整时，n-1结果低位才是全1
(2)2   = 0000 0000 0000 0010    -1   (1)2  =  0000 0000 0000 0001
(4)2   = 0000 0000 0000 0100    -1   (3)2  =  0000 0000 0000 0011
(8)2   = 0000 0000 0000 1000    -1   (7)2  =  0000 0000 0000 0111 

```

* 当table[i]所在位置的链表长度超过TREEIFY_THRESHOLD(默认8）时将会将链表转换为红黑树
```
链表的时间复杂度为O(N)，N为链表长度
而树的时间复杂度为O(log(N))
```

* java.util.HashMap#resize中扩容后，移动元素 if ((e.hash & oldCap) == 0)
```
if ((e.hash & oldCap) == 0) 存在旧位置
else 在新位置

因oldCap为2的N次幂，如8，16，32等
(16)2   = 0000 0000 0001 0000

```
